#version 450

#extension GL_GOOGLE_include_directive : enable

#include "scene_ubo.glsl"
#include "octahedron_helpers.glsl"

layout (local_size_x = 8, local_size_y = 8) in;

layout(set = 1, binding = 0, rgba16f) uniform readonly image2D irrIm;
layout(set = 1, binding = 1, rgba16f) uniform readonly image2D dirIm;
layout(set = 1, binding = 2, rgba16f) uniform image2D outputIm;

void main()
{
  const int octPixelSize = 8;
  const int numProbesPerPlane = 32;
  const int numProbePlanes = 8;
  const int inputPixSize = 16;
  const int xs = numProbesPerPlane * octPixelSize;
  const int ys = numProbesPerPlane * numProbePlanes * octPixelSize;

  if (gl_GlobalInvocationID.x > xs || gl_GlobalInvocationID.y > ys) {
    return;
  }
  
  ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);

  ivec2 probeIdx = pixel / octPixelSize;
  ivec2 probeStartPixel = probeIdx * inputPixSize; // in input image pixels
  ivec2 pixelWithinProbe = pixel - probeIdx * octPixelSize;

  // 16x16 kernel
  int kernelSize = inputPixSize;

  ivec2 pixOffset = 2 * probeIdx + 1;
  vec2 octUv = vec2(float(pixelWithinProbe.x) + 0.5, float(pixelWithinProbe.y) + 0.5) / float(octPixelSize);
  octUv = octUv * 2.0 - 1.0;
  vec3 octDir = octDecode(octUv);

  vec4 result = vec4(0.0);
  for (int x = 0; x < kernelSize; ++x) {
    for (int y = 0; y < kernelSize; ++y) {
      
      if (x > xs - 1 || y > ys - 1) {
        continue;
      }

      ivec2 currPix = probeStartPixel + ivec2(x, y);

      vec3 irradiance = imageLoad(irrIm, currPix).rgb;
      vec3 dir = imageLoad(dirIm, currPix).rgb;
      float weight = max(0.0, dot(dir, octDir));
      if (weight > 1e-6) {
        result += vec4(weight * irradiance, weight);
      }
    }
  }

  // Add old value
  //vec4 oldVal = imageLoad(outputIm, pixOffset + pixel);

  if (result.w > 1e-6) {
    result.rgb /= result.w;
  }

  //float hysteresis = 0.0;
  //vec4 outRes = result * (1.0 - hysteresis) + oldVal * hysteresis;
  vec4 outRes = result;

  imageStore(outputIm, pixOffset + pixel, outRes);
}