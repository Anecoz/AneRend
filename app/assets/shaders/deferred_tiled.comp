#version 450

#extension GL_GOOGLE_include_directive : enable

layout (local_size_x = 32, local_size_y = 32) in;

#include "scene_ubo.glsl"
#include "bindless.glsl"
#include "pbr_light.glsl"

layout(set = 1, binding = 0) uniform sampler2D im0;
layout(set = 1, binding = 1) uniform sampler2D im1;
//layout(set = 1, binding = 2) uniform sampler2D im2;
layout(set = 1, binding = 2) uniform sampler2D depth;
layout(set = 1, binding = 3) uniform sampler2D shadowMap;
layout(set = 1, binding = 4) uniform sampler2D ssao;
layout(set = 1, binding = 5) uniform sampler2D rtShadowMask;
layout(set = 1, binding = 6, rgba16) uniform writeonly image2D outputIm;

layout(push_constant) uniform constants {
  uint screenWidth;
  uint screenHeight;
} pushConstants;

// The index list that will need to be processed by this particular invocation
shared uint groupLocalIndexList[32 * 32]; // Worst case size is _all_ lights

// The actual size of the above array
shared uint groupLocalNumIndices;

void doLight(ivec2 pixel);

const vec3 clearColor = vec3(0.2, 0.5, 0.7);

void main()
{
  if (gl_GlobalInvocationID.x > pushConstants.screenWidth || gl_GlobalInvocationID.y > pushConstants.screenHeight) {
    return;
  }

  if (gl_LocalInvocationID.x == 0 && 
      gl_LocalInvocationID.y == 0 &&
      gl_LocalInvocationID.z == 0) {
    groupLocalNumIndices = 0;
  }

  // Early exit if we're in the sky
  ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
  vec2 texCoords = vec2(pixel) / vec2(ubo.screenWidth - 1, ubo.screenHeight - 1);

  float depthSamp = texture(depth, texCoords).r;

  if (depthSamp == 1.0f) {
    imageStore(outputIm, pixel, vec4(clearColor, 1.0));
    return;
  }

  barrier();

  // Project a light into screen space and check if it is in our current invocation tile.
  uint lightIndex = gl_LocalInvocationID.x * gl_WorkGroupSize.y + gl_LocalInvocationID.y;
  Light light = lightBuffer.lights[lightIndex];

  if (light.color.w > 0.5) {
    vec2 center = vec2( pushConstants.screenWidth,  pushConstants.screenHeight) / float(2 * gl_WorkGroupSize.x); // Location of the middle work group
    vec2 offset = center - vec2(gl_WorkGroupID.xy);
 
    // Extract the viewing frustum planes (normals)
    // https://gamedev.stackexchange.com/questions/156743/finding-the-normals-of-the-planes-of-a-view-frustum
    vec4 column0 = vec4(-ubo.proj[0][0] * center.x, ubo.proj[0][1], offset.x, ubo.proj[0][3]); // (-2 * n' / (r - l) * 80, 0, offset.x, 0)
    vec4 column1 = vec4(ubo.proj[1][0], -ubo.proj[1][1] * center.y, offset.y, ubo.proj[1][3]); // (0, -2 * n' / (t - b) * 45, offset.y, 0)
    vec4 column3 = vec4(ubo.proj[3][0], ubo.proj[3][1], -1.0f, ubo.proj[3][3]); // (0, 0, -1, 0)
 
    vec4 frustumPlanes[4];
    // Left
    frustumPlanes[0] = column3 + column0;
    // Right
    frustumPlanes[1] = column3 - column0;
    // Top
    frustumPlanes[2] = column3 - column1;
    // Bottom
    frustumPlanes[3] = column3 + column1;
    for (int i = 0; i < 4; ++i) {
      frustumPlanes[i] /= length(frustumPlanes[i].xyz);
    }

    vec4 lightView =  ubo.view * vec4(light.worldPos.xyz, 1.0f);
    bool inFrustum = true;//distance(ubo.cameraPos.xyz, light.worldPos.xyz) < 50.0;
    inFrustum = inFrustum && lightView.z > -50.0;
    inFrustum = inFrustum && lightView.z < 1.0;
    if (inFrustum) {
      for (int j = 3; j >= 0 && inFrustum; --j) {
        float d = dot(frustumPlanes[j], lightView); // Distance of the point from the plane
        // https://gamedev.stackexchange.com/questions/79172/checking-if-a-vector-is-contained-inside-a-viewing-frustum
        inFrustum = -light.worldPos.w <= d;
      }
      if (inFrustum) {
        uint countBefore = atomicAdd(groupLocalNumIndices, 1);
        groupLocalIndexList[countBefore] = lightIndex;
      }
    }
  }

  barrier();

  doLight(pixel);
}

float inShadow(vec3 worldPos) {
  vec4 shadowPos = ubo.directionalShadowMatrixProj * ubo.directionalShadowMatrixView * vec4(worldPos, 1.0);
  vec3 projCoords = shadowPos.xyz / shadowPos.w;

  if (projCoords.x > 1.0 || projCoords.x < -1.0 ||
      projCoords.z > 1.0 || projCoords.z < 0.0 ||
      projCoords.y > 1.0 || projCoords.y < -1.0) {
    return 0.0;
  }

  vec2 shadowMapCoord = projCoords.xy * 0.5 + 0.5;

  float depth = projCoords.z;
  float sampledDepth = texture(shadowMap, shadowMapCoord.xy).r;
  if (depth > sampledDepth) {
    return 1.0;
  }
  return 0.0;
}

vec3 calcWorldPos(vec2 texCoord, float depthSamp)
{
  vec4 clipSpacePos = vec4(texCoord * 2.0 - vec2(1.0), depthSamp, 1.0);

  //vec4 position = inverse_projection_matrix * clip_space_position; // Use this for view space
  vec4 position = ubo.invViewProj * clipSpacePos; // Use this for world space

  return(position.xyz / position.w);
}

void doLight(ivec2 pixel)
{
  vec2 texCoords = vec2(pixel) / vec2(ubo.screenWidth - 1, ubo.screenHeight - 1);

  vec4 im0Samp = texture(im0, texCoords);
  vec4 im1Samp = texture(im1, texCoords);
  //vec4 im2Samp = texture(im2, texCoords);
  float depthSamp = texture(depth, texCoords).r;

  if (depthSamp == 1.0f) {
    imageStore(outputIm, pixel, vec4(0.5, 0.5, 0.5, 1.0));
    return;
  }

  vec3 normal = im0Samp.rgb * 2.0 - 1.0;
  vec3 albedo = vec3(im0Samp.a, im1Samp.rg);//pow(vec3(im0Samp.a, im1Samp.rg), vec3(2.2));
  float metallic = im1Samp.b;
  float roughness = im1Samp.a;
  float depth = depthSamp;
  vec3 fragWorldPos = calcWorldPos(texCoords, depthSamp);//im2Samp.rgb;//calcWorldPos(texCoords, depthSamp);
  float shadow = 1.0f;
  float occlusion = 1.0f;
  
  if (ubo.directionalShadowsEnabled == 1) {
    shadow = inShadow(fragWorldPos);
    shadow = clamp(1.0 - shadow, 0.3, 1.0);
  }
  else if (ubo.rtShadowsEnabled == 1) {
    shadow = 1.0 - texture(rtShadowMask, texCoords).r;
    shadow = clamp(1.0 - shadow, 0.3, 1.0);
  }

  if (ubo.ssaoEnabled == 1) {
    occlusion = texture(ssao, texCoords).r;  
  }

  vec3 Lo = vec3(0.0);
  vec3 directionalLo = vec3(0.0);
  for (int i = 0; i < 1 + groupLocalNumIndices; ++i) {

    Light light = lightBuffer.lights[groupLocalIndexList[i-1]];

    if (i == 0) {
      directionalLo += calcLight(
        normal,
        albedo,
        metallic,
        roughness,
        fragWorldPos,
        light,
        1);
    }
    else {
      Lo += calcLight(
        normal,
        albedo,
        metallic,
        roughness,
        fragWorldPos,
        light,
        0);
    }
  }

  vec3 ambient = vec3(0.3) * albedo * shadow;
  directionalLo *= shadow;
  vec3 color = (ambient + Lo + directionalLo) * occlusion;

  imageStore(outputIm, pixel, vec4(color, 1.0));
}