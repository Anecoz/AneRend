#version 450

#extension GL_GOOGLE_include_directive : enable

layout (local_size_x = 32, local_size_y = 32) in;

#include "scene_ubo.glsl"
#include "bindless.glsl"
#include "octahedron_helpers.glsl"
#include "pbr_light.glsl"
//#include "compass_directions.glsl"
//#include "probe_helpers.glsl"

layout(set = 1, binding = 0) uniform sampler2D im0;
layout(set = 1, binding = 1) uniform sampler2D im1;
//layout(set = 1, binding = 2) uniform sampler2D im2;
layout(set = 1, binding = 2) uniform sampler2D depth;
layout(set = 1, binding = 3) uniform sampler2D shadowMap;
layout(set = 1, binding = 4) uniform sampler2D ssao;
layout(set = 1, binding = 5) uniform sampler2D rtShadowMask;

/*layout(std430, set = 1, binding = 6) readonly buffer IrradianceProbeBuffer {
  IrradianceProbe probes[];
} irradianceProbeBuffer;*/

layout(set = 1, binding = 6, rgba16) uniform writeonly image2D outputIm;
//layout(set = 1, binding = 7, rgba8) uniform readonly image2D surfelTex;
//layout(set = 1, binding = 7) uniform sampler2D surfelTex;
//layout(set = 1, binding = 7) uniform sampler2D ssgiBlurTex;
layout(set = 1, binding = 7) uniform sampler2D probeTex;
layout(set = 1, binding = 8) uniform sampler2D specularGiTex;

layout(push_constant) uniform constants {
  uint screenWidth;
  uint screenHeight;
} pushConstants;

// The index list that will need to be processed by this particular invocation
shared uint groupLocalIndexList[32 * 32]; // Worst case size is _all_ lights

// The actual size of the above array
shared uint groupLocalNumIndices;

void doLight(ivec2 pixel);

const vec3 clearColor = vec3(0.2, 0.5, 0.7);

void main()
{
  if (gl_GlobalInvocationID.x > pushConstants.screenWidth || gl_GlobalInvocationID.y > pushConstants.screenHeight) {
    return;
  }

  if (gl_LocalInvocationID.x == 0 && 
      gl_LocalInvocationID.y == 0 &&
      gl_LocalInvocationID.z == 0) {
    groupLocalNumIndices = 0;
  }

  // Early exit if we're in the sky
  ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
  vec2 texCoords = (vec2(pixel) + 0.5) / vec2(ubo.screenWidth, ubo.screenHeight);

  float depthSamp = texture(depth, texCoords).r;

  if (depthSamp == 1.0f) {
    imageStore(outputIm, pixel, vec4(clearColor, 1.0));
    return;
  }

  barrier();

  // Project a light into screen space and check if it is in our current invocation tile.
  uint lightIndex = gl_LocalInvocationID.x * gl_WorkGroupSize.y + gl_LocalInvocationID.y;
  Light light = lightBuffer.lights[lightIndex];

  if (light.color.w > 0.5) {
    vec2 center = vec2( pushConstants.screenWidth,  pushConstants.screenHeight) / float(2 * gl_WorkGroupSize.x); // Location of the middle work group
    vec2 offset = center - vec2(gl_WorkGroupID.xy);
 
    // Extract the viewing frustum planes (normals)
    // https://gamedev.stackexchange.com/questions/156743/finding-the-normals-of-the-planes-of-a-view-frustum
    vec4 column0 = vec4(-ubo.proj[0][0] * center.x, ubo.proj[0][1], offset.x, ubo.proj[0][3]); // (-2 * n' / (r - l) * 80, 0, offset.x, 0)
    vec4 column1 = vec4(ubo.proj[1][0], -ubo.proj[1][1] * center.y, offset.y, ubo.proj[1][3]); // (0, -2 * n' / (t - b) * 45, offset.y, 0)
    vec4 column3 = vec4(ubo.proj[3][0], ubo.proj[3][1], -1.0f, ubo.proj[3][3]); // (0, 0, -1, 0)
 
    vec4 frustumPlanes[4];
    // Left
    frustumPlanes[0] = column3 + column0;
    // Right
    frustumPlanes[1] = column3 - column0;
    // Top
    frustumPlanes[2] = column3 - column1;
    // Bottom
    frustumPlanes[3] = column3 + column1;
    for (int i = 0; i < 4; ++i) {
      frustumPlanes[i] /= length(frustumPlanes[i].xyz);
    }

    vec4 lightView =  ubo.view * vec4(light.worldPos.xyz, 1.0f);
    bool inFrustum = true;//distance(ubo.cameraPos.xyz, light.worldPos.xyz) < 50.0;
    inFrustum = inFrustum && lightView.z > -50.0;
    inFrustum = inFrustum && lightView.z < 1.0;
    if (inFrustum) {
      for (int j = 3; j >= 0 && inFrustum; --j) {
        float d = dot(frustumPlanes[j], lightView); // Distance of the point from the plane
        // https://gamedev.stackexchange.com/questions/79172/checking-if-a-vector-is-contained-inside-a-viewing-frustum
        inFrustum = -light.worldPos.w <= d;
      }
      if (inFrustum) {
        uint countBefore = atomicAdd(groupLocalNumIndices, 1);
        groupLocalIndexList[countBefore] = lightIndex;
      }
    }
  }

  barrier();

  doLight(pixel);
}

float inShadow(vec3 worldPos) {
  vec4 shadowPos = ubo.directionalShadowMatrixProj * ubo.directionalShadowMatrixView * vec4(worldPos, 1.0);
  vec3 projCoords = shadowPos.xyz / shadowPos.w;

  if (projCoords.x > 1.0 || projCoords.x < -1.0 ||
      projCoords.z > 1.0 || projCoords.z < 0.0 ||
      projCoords.y > 1.0 || projCoords.y < -1.0) {
    return 0.0;
  }

  vec2 shadowMapCoord = projCoords.xy * 0.5 + 0.5;

  float depth = projCoords.z;
  float sampledDepth = texture(shadowMap, shadowMapCoord.xy).r;
  if (depth > sampledDepth) {
    return 1.0;
  }
  return 0.0;
}

vec3 calcWorldPos(vec2 texCoord, float depthSamp)
{
  vec4 clipSpacePos = vec4(texCoord * 2.0 - vec2(1.0), depthSamp, 1.0);

  //vec4 position = inverse_projection_matrix * clip_space_position; // Use this for view space
  vec4 position = ubo.invViewProj * clipSpacePos; // Use this for world space

  return(position.xyz / position.w);
}

/*vec3 sampleSingleProbe(ivec3 probeIndex, vec3 normal)
{
  const int probePixSize = 8;
  const int probesPerPlane = 32;
  ivec2 probeTexSize = textureSize(probeTex, 0);

  ivec2 probePixelStart = ivec2(
    (probePixSize + 2) * probeIndex.x + 1,
    (probePixSize + 2) * probesPerPlane * probeIndex.y + (probePixSize + 2) * probeIndex.z + 1);

  ivec2 probePixelEnd = probePixelStart + probePixSize - 1;

  vec2 probeTexStart = vec2(
    float(probePixelStart.x) / float(probeTexSize.x - 1),
    float(probePixelStart.y) / float(probeTexSize.y - 1));

  vec2 probeTexEnd = vec2(
    float(probePixelEnd.x) / float(probeTexSize.x - 1),
    float(probePixelEnd.y) / float(probeTexSize.y - 1));

  // This returns on -1 to 1, so change to 0 to 1
  vec2 oct = octEncode(normalize(normal));
  oct = (oct + vec2(1.0)) * 0.5;

  vec2 octTexCoord = probeTexStart + (probeTexEnd - probeTexStart) * oct;

  vec4 irr = texture(probeTex, octTexCoord);
  return irr.rgb / irr.w;
  //return texture(probeTex, octTexCoord).rgb;
}

vec4 weightProbe(vec3 worldPos, vec3 normal, ivec3 probeIndex, vec3 alpha, ivec3 offset)
{
  vec3 probePos = vec3(probeIndex.x, probeIndex.y, probeIndex.z);
  vec3 trilinear = mix(1.0 - alpha, alpha, offset);
  float weight = 1.0;
  vec3 probeIrradiance = vec3(0.0);

  // Smooth backface test
  {
    // Computed without the biasing applied to the "dir" variable. 
    // This test can cause reflection-map looking errors in the image
    // (stuff looks shiny) if the transition is poor.
    vec3 trueDirectionToProbe = normalize(probePos - worldPos);

    // The naive soft backface weight would ignore a probe when
    // it is behind the surface. That's good for walls. But for small details inside of a
    // room, the normals on the details might rule out all of the probes that have mutual
    // visibility to the point. So, we instead use a "wrap shading" test below inspired by
    // NPR work.
    // weight *= max(0.0001, dot(trueDirectionToProbe, wsN));

    // The small offset at the end reduces the "going to zero" impact
    // where this is really close to exactly opposite
    weight *= pow(max(0.0001, (dot(trueDirectionToProbe, normal) + 1.0) * 0.5), 2) + 0.2;
  }

  // Avoid zero weight
  weight = max(0.000001, weight);

  // A tiny bit of light is really visible due to log perception, so
  // crush tiny weights but keep the curve continuous. This must be done
  // before the trilinear weights, because those should be preserved.
  const float crushThreshold = 0.2;
  if (weight < crushThreshold) {
      weight *= weight * weight * (1.0 / pow(crushThreshold, 2)); 
  }

  // Trilinear weights
  weight *= trilinear.x * trilinear.y * trilinear.z;

  probeIrradiance += sampleSingleProbe(probeIndex, normal);

  // Weight in a more-perceptual brightness space instead of radiance space.
  // This softens the transitions between probes with respect to translation.
  // It makes little difference most of the time, but when there are radical transitions
  // between probes this helps soften the ramp.
  probeIrradiance = sqrt(probeIrradiance);

  return vec4(probeIrradiance, weight);
}

vec3 sampleProbe(vec3 worldPos, vec3 normal)
{
  // Find closest probe to worldPos
  int probeX = clamp(int(floor(worldPos.x)), 0, 31);
  int probeY = clamp(int(floor(worldPos.y / 2.0)), 0, 7);
  int probeZ = clamp(int(floor(worldPos.z)), 0, 31);

  vec3 baseProbePos = vec3(probeX, probeY, probeZ);
  vec3 probeStep = vec3(1.0, 2.0, 1.0);

  float sumWeight = 0.0;
  vec3 sumIrradiance = vec3(0.0);

  // alpha is how far from the floor(currentVertex) position. on [0, 1] for each axis.
  vec3 alpha = clamp((worldPos - baseProbePos) / probeStep, vec3(0.0), vec3(1.0));

  vec4 res = weightProbe(worldPos, normal, ivec3(probeX, probeY, probeZ), alpha, ivec3(0));
  sumIrradiance += res.w * res.rgb;
  sumWeight += res.w;

  res = weightProbe(worldPos, normal, ivec3(probeX+1, probeY+1, probeZ+1), alpha, ivec3(1, 1, 1));
  sumIrradiance += res.w * res.rgb;
  sumWeight += res.w;

  res = weightProbe(worldPos, normal, ivec3(probeX+1, probeY+1, probeZ), alpha, ivec3(1, 1, 0));
  sumIrradiance += res.w * res.rgb;
  sumWeight += res.w;

  res = weightProbe(worldPos, normal, ivec3(probeX+1, probeY, probeZ), alpha, ivec3(1, 0, 0));
  sumIrradiance += res.w * res.rgb;
  sumWeight += res.w;

  res = weightProbe(worldPos, normal, ivec3(probeX, probeY+1, probeZ+1), alpha, ivec3(0, 1, 1));
  sumIrradiance += res.w * res.rgb;
  sumWeight += res.w;

  res = weightProbe(worldPos, normal, ivec3(probeX, probeY+1, probeZ), alpha, ivec3(0, 1, 0));
  sumIrradiance += res.w * res.rgb;
  sumWeight += res.w;

  res = weightProbe(worldPos, normal, ivec3(probeX, probeY, probeZ+1), alpha, ivec3(0, 0, 1));
  sumIrradiance += res.w * res.rgb;
  sumWeight += res.w;

  res = weightProbe(worldPos, normal, ivec3(probeX+1, probeY, probeZ+1), alpha, ivec3(1, 0, 1));
  sumIrradiance += res.w * res.rgb;
  sumWeight += res.w;

  vec3 netIrradiance = sumIrradiance / sumWeight;

  // Go back to linear irradiance
  netIrradiance = pow(netIrradiance, ivec3(2));

  return netIrradiance * 2.0 * 3.1415926;
}*/

// Get the pixel coordinate of the surfel that input pixel belongs to (the middle of the surfel)
/*ivec2 surfelPixelCoordinate(ivec2 pixel)
{
  const int surfelPixelSize = 32;

  ivec2 surfelPixelStart = ivec2(
  int(floor(float(pixel.x) / float(surfelPixelSize))) * surfelPixelSize,
  int(floor(float(pixel.y) / float(surfelPixelSize))) * surfelPixelSize);

  return surfelPixelStart + ivec2(surfelPixelSize/2);
}

vec3 surfelIrradianceAtPixel(ivec2 pixel, vec3 normal)
{
  vec3 surfelIrradiance = vec3(0.0);
  const int octPixelSize = 8;
  const int surfelPixelSize = 32;
  const int numSurfelsX = int(ubo.screenWidth) / surfelPixelSize;
  const int numSurfelsY = int(ceil(float(ubo.screenHeight) / float(surfelPixelSize)));
  const int octTexWidth = numSurfelsX * octPixelSize + numSurfelsX * 2;
  const int octTexHeight = numSurfelsY * octPixelSize + numSurfelsY * 2;

  ivec2 surfelPixelStart = ivec2(
    int(floor(float(pixel.x) / float(surfelPixelSize))) * (octPixelSize + 2) + 1,
    int(floor(float(pixel.y) / float(surfelPixelSize))) * (octPixelSize + 2) + 1);

  ivec2 surfelPixelEnd = surfelPixelStart + octPixelSize - 1;

  vec2 surfTexStart = vec2(
    (float(surfelPixelStart.x) + 0.0) / float(octTexWidth - 1),
    (float(surfelPixelStart.y) + 0.0) / float(octTexHeight - 1));

  vec2 surfTexEnd = vec2(
    (float(surfelPixelEnd.x) + 0.0) / float(octTexWidth - 1),
    (float(surfelPixelEnd.y) + 0.0) / float(octTexHeight - 1));

  // This returns on -1 to 1, so change to 0 to 1
  vec2 oct = octEncode(normalize(normal));
  oct = (oct + vec2(1.0)) * 0.5;

  vec2 octTexCoord = surfTexStart + (surfTexEnd - surfTexStart) * oct;
  vec2 texelSize = vec2(1.0 / float(octPixelSize));

  surfelIrradiance = texture(surfelTex, octTexCoord).rgb;

  // Weight by distance to center of surfel
  //vec2 pixelInOctTex = vec2(texCoord.x * float(octTexWidth), texCoord.y * float(octTexHeight));
  //vec2 surfelCenterInPixels = vec2(float(surfelPixelEnd.x) - float(surfelPixelStart.x), float(surfelPixelEnd.y) - float(surfelPixelStart.y));

  //float weight = 1.0 / distance(pixelInOctTex, surfelCenterInPixels);
  //weight *= 100.0;

  //ivec2 octPixel = ivec2(octTexCoord.x * octTexWidth - 1, octTexCoord.y * octTexHeight - 1);
  //surfelIrradiance = imageLoad(surfelTex, octPixel).rgb;
  //surfelIrradiance = normal;
  //surfelIrradiance = vec3(oct.x, oct.y, 0.0);
  return surfelIrradiance;
}

vec3 sampleSurfels(vec2 texCoord, vec3 normal)
{
  vec4 surfelIrradiance = vec4(0.0);
  const int surfelPixelSize = 32;

  // Find closest 8 surfels and interpolate their radiance
  ivec2 pixel = ivec2(
    round(texCoord.x * float(ubo.screenWidth)) - 1,
    round(texCoord.y * float(ubo.screenHeight)) - 1);

  //ivec2 surfPixCoord = surfelPixelCoordinate(pixel);
  //float d = distance(vec2(surfPixCoord.x, surfPixCoord.y), vec2(pixel.x, pixel.y)) / (float(surfelPixelSize) / 1.5);
  //float weight = clamp(1.0 - d * d, 0.0, 1.0);
  //surfelIrradiance = weight * vec4(surfelIrradianceAtPixel(pixel, normal), 1.0);

  //surfelIrradiance = vec4(surfelIrradianceAtPixel(pixel, normal), 1.0);

  ivec2 pixels[9];
  pixels[0] = pixel + ivec2(surfelPixelSize, surfelPixelSize);
  pixels[1] = pixel + ivec2(-surfelPixelSize, -surfelPixelSize);
  pixels[2] = pixel + ivec2(-surfelPixelSize, surfelPixelSize);
  pixels[3] = pixel + ivec2(surfelPixelSize, -surfelPixelSize);
  pixels[4] = pixel + ivec2(surfelPixelSize, 0);
  pixels[5] = pixel + ivec2(-surfelPixelSize, 0);
  pixels[6] = pixel + ivec2(0, surfelPixelSize);
  pixels[7] = pixel + ivec2(0, -surfelPixelSize);
  pixels[8] = pixel;

  for (int i = 0; i < 9; ++i) {
    ivec2 surfPixCoord = surfelPixelCoordinate(pixels[i]);
    float weight = 1.0;//clamp(1.0 - (distance(float(surfPixCoord), float(pixel)) / 16.0), 0.0, 1.0);
    surfelIrradiance += vec4(weight * surfelIrradianceAtPixel(pixels[i], normal), weight);
  }

  if (surfelIrradiance.w > 1e-6) {
    //surfelIrradiance.rgb /= surfelIrradiance.w;
    surfelIrradiance.rgb /= 9.0;
    surfelIrradiance *= 3.1415926 * 0.5;
  }

  return surfelIrradiance.rgb;
}*/

void doLight(ivec2 pixel)
{
  vec2 texCoords = (vec2(pixel) + 0.5) / vec2(ubo.screenWidth, ubo.screenHeight);

  vec4 im0Samp = texture(im0, texCoords);
  vec4 im1Samp = texture(im1, texCoords);
  //vec4 im2Samp = texture(im2, texCoords);
  float depthSamp = texture(depth, texCoords).r;

  if (depthSamp == 1.0f) {
    imageStore(outputIm, pixel, vec4(0.5, 0.5, 0.5, 1.0));
    return;
  }

  vec3 normal = im0Samp.rgb * 2.0 - 1.0;
  vec3 albedo = vec3(im0Samp.a, im1Samp.rg);//pow(vec3(im0Samp.a, im1Samp.rg), vec3(2.2));
  float metallic = im1Samp.b;
  float roughness = im1Samp.a;
  float depth = depthSamp;
  vec3 fragWorldPos = calcWorldPos(texCoords, depthSamp);//im2Samp.rgb;//calcWorldPos(texCoords, depthSamp);
  float shadow = 1.0f;
  float occlusion = 1.0f;
  
  if (ubo.directionalShadowsEnabled == 1) {
    shadow = inShadow(fragWorldPos);
    shadow = clamp(1.0 - shadow, 0.0, 1.0);
  }
  else if (ubo.rtShadowsEnabled == 1) {
    shadow = texture(rtShadowMask, texCoords).r;
    //shadow = clamp(1.0 - shadow, 0.0, 1.0);
  }

  if (ubo.ssaoEnabled == 1) {
    occlusion = texture(ssao, texCoords).r;  
  }

  vec3 Lo = vec3(0.0);
  vec3 directionalLo = vec3(0.0);
  vec3 ambient = vec3(0.0);//vec3(0.3) * albedo * shadow;

  for (int i = 0; i < 1 + groupLocalNumIndices; ++i) {

    if (i == 0) {
      // Only do direct lighting if we're directly lit
      if (shadow > 0.5) {
        Light dummyLight;
        directionalLo += calcLight(
          normal,
          albedo,
          metallic,
          roughness,
          fragWorldPos,
          dummyLight,
          1);
      }
    }
    else {
      Light light = lightBuffer.lights[groupLocalIndexList[i-1]];
      Lo += calcLight(
        normal,
        albedo,
        metallic,
        roughness,
        fragWorldPos,
        light,
        0);
    }
  }

  ambient += calcIndirectDiffuseLight(
    normal,
    albedo,
    metallic,
    roughness,
    fragWorldPos,
    ubo.cameraPos.xyz,
    probeTex);

  ambient += calcIndirectSpecularLight(
    normal,
    albedo,
    metallic,
    roughness,
    fragWorldPos,
    texCoords,
    specularGiTex);

  directionalLo *= shadow;
  vec3 color = (ambient + Lo + directionalLo) * occlusion;

  color = color / (color + vec3(1.0));

  //imageStore(outputIm, pixel, vec4(normal, 1.0));
  imageStore(outputIm, pixel, vec4(color, 1.0));
}


  // TESTING PROBES
  // max xyz is (32, 16, 32)
  /*int probeWidth = 32;
  int probeHeight = 8;
  int probeDepth = 32;
  int xMin = int(floor(fragWorldPos.x));
  int yMin = int(floor(fragWorldPos.y/2.0));
  int zMin = int(floor(fragWorldPos.z));

  int xMax = xMin + 1;
  int yMax = yMin + 1;
  int zMax = zMin + 1;

  if (shadow < 0.5) {
    if (xMin < probeWidth - 1 && xMin > 0 &&
        yMin < probeHeight - 1 && yMin > 0 &&
        zMin < probeDepth - 1 && zMin > 0 &&
        xMax < probeWidth - 1 && xMax > 0 &&
        yMax < probeHeight - 1 && yMax > 0 &&
        zMax < probeDepth - 1 && zMax > 0) {
      IrradianceProbe probes[8];
      probes[0] = irradianceProbeBuffer.probes[xMin + (yMin * probeWidth) + (zMin * probeWidth * probeHeight)];
      probes[1] = irradianceProbeBuffer.probes[xMin + (yMin * probeWidth) + (zMax * probeWidth * probeHeight)];
      probes[2] = irradianceProbeBuffer.probes[xMin + (yMax * probeWidth) + (zMax * probeWidth * probeHeight)];
      probes[3] = irradianceProbeBuffer.probes[xMax + (yMax * probeWidth) + (zMax * probeWidth * probeHeight)];
      probes[4] = irradianceProbeBuffer.probes[xMax + (yMax * probeWidth) + (zMin * probeWidth * probeHeight)];
      probes[5] = irradianceProbeBuffer.probes[xMax + (yMin * probeWidth) + (zMin * probeWidth * probeHeight)];
      probes[6] = irradianceProbeBuffer.probes[xMin + (yMax * probeWidth) + (zMin * probeWidth * probeHeight)];
      probes[7] = irradianceProbeBuffer.probes[xMax + (yMin * probeWidth) + (zMax * probeWidth * probeHeight)];

      float weights = 0.0;
      for (int i = 0; i < 8; i++) {
        float d = distance(probes[i].pos.xyz, fragWorldPos);
        float weight = 1.0/(d * d);
        if (weight > 0.001) {
          ambient += weight * getProbeIrradiance(probes[i], normal);
          weights += weight;
        }
      }

      if (weights > 0.001) {
        ambient /= weights;
      }
    }
  }*/