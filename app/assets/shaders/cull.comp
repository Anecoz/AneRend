#version 450

layout (local_size_x = 32, local_size_y = 32) in;

struct DrawCommand
{
  uint indexCount;
  uint instanceCount;
  uint firstIndex;
  int vertexOffset;
  uint firstInstance;
};

struct GrassDrawCommand
{
  uint vertexCount;
  uint instanceCount;
  uint firstVertex;
  uint firstInstance;
};

struct Renderable
{
  mat4 transform;
  vec4 bounds;
  uint meshId;
  uint visible;
};

struct GrassObj
{
  vec4 worldPos;
  vec4 data; // x and y: facing dir, z: tilt, w: bend
  vec4 data2; //x: per-blade hash
};

layout(std430, set = 0, binding = 2) readonly buffer RenderableBuffer {
  Renderable renderables[];
} renderableBuffer;

layout(std430, set = 1, binding = 0) buffer DrawBuffer {
  DrawCommand draws[];
} drawBuffer;

layout(std430, set = 1, binding = 1) buffer TranslationBuffer {
  uint ids[];
} translationBuffer;

layout(std430, set = 1, binding = 2) buffer GrassDrawBuffer {
  GrassDrawCommand draw;
} grassDrawBuffer;

layout(std430, set = 1, binding = 3) buffer GrassObjBuffer {
  GrassObj blades[];
} grassObjBuffer;

layout(push_constant) uniform constants {
  mat4 view;
  vec4 frustumPlanes[4];
  float nearDist;
  float farDist;
  uint drawCount;
  float windStrength; // temp
} pushConstants;

const uint k = 1103515245U;  // GLIB C

vec3 hash(uvec3 x)
{
  x = ((x>>8U)^x.yzx)*k;
  x = ((x>>8U)^x.yzx)*k;
  x = ((x>>8U)^x.yzx)*k;
    
  return vec3(x)*(1.0/float(0xffffffffU));
}

float rand(vec2 co){
  return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

bool sphereVisible(vec3 sphereCenter, float sphereRadius)
{
  bool visible = true;
  for (int i = 0; i < 4; i++) {
    vec3 frustumNormal = pushConstants.frustumPlanes[i].xyz;
    float frustumD = pushConstants.frustumPlanes[i].w;
    bool inFrustum = (dot(sphereCenter, frustumNormal) + frustumD + sphereRadius) >= 0.0;
    visible = visible && inFrustum;
  }

  return visible;
}

void main()
{
  // Renderable culling
  uint gID = gl_GlobalInvocationID.x * gl_NumWorkGroups.x * 32 + gl_GlobalInvocationID.y;

  if (gID < pushConstants.drawCount) {

    // Check visibility against frustum planes
    bool visible = renderableBuffer.renderables[gID].visible == 1 ? true : false;
    if (visible) {

      mat4 model = renderableBuffer.renderables[gID].transform;
      vec4 sphereBounds = renderableBuffer.renderables[gID].bounds;
      float radius = sphereBounds.w;
      vec3 sphereCenterView = vec3(pushConstants.view * model * vec4(sphereBounds.xyz, 1.0));
      vec3 sphereCenter = vec3(model * vec4(sphereBounds.xyz, 1.0));

      visible = visible && sphereCenterView.z > -pushConstants.farDist;
      visible = visible && sphereCenterView.z < pushConstants.nearDist;
      visible = visible && sphereVisible(sphereCenter, radius);

      if (visible) {

        uint meshId = renderableBuffer.renderables[gID].meshId;
        uint countBefore = atomicAdd(drawBuffer.draws[meshId].instanceCount, 1);

        // Update translation buffer (from gl_InstanceIndex to renderableId)
        uint instanceIndex = drawBuffer.draws[meshId].firstInstance + countBefore;
        translationBuffer.ids[instanceIndex] = gID;
      }
    }
  }

  // Grass
  uint xPos = gl_GlobalInvocationID.x;
  uint yPos = gl_GlobalInvocationID.y;

  vec3 worldPos = vec3(xPos*0.08, .25, yPos*0.08);
  float radius = 1.5;
  bool visible = sphereVisible(worldPos, radius);

  if (visible) {
    uint countBefore = atomicAdd(grassDrawBuffer.draw.instanceCount, 1);

    float bladeHash = rand(vec2(worldPos.x, worldPos.z));
    vec2 bladeHash2D = vec2(
      rand(vec2(worldPos.x / bladeHash, worldPos.z)),
      rand(vec2(worldPos.x, worldPos.z * bladeHash)));

    // Jitter position slightly
    worldPos.x += bladeHash * 0.5;
    worldPos.z += bladeHash * 0.5;

    uint instanceIndex = grassDrawBuffer.draw.firstInstance + countBefore;
    float height = .5 * max(bladeHash2D.y, 0.3);

    vec2 facing = normalize(bladeHash2D * 2.0 - 1.0);
    vec2 windDir = vec2(-1.0, 0.0);

    grassObjBuffer.blades[instanceIndex].worldPos = vec4(worldPos, height);
    grassObjBuffer.blades[instanceIndex].data.xy = normalize(facing*(1.0 - pushConstants.windStrength) + windDir*pushConstants.windStrength);
    grassObjBuffer.blades[instanceIndex].data.z = min(bladeHash + pushConstants.windStrength, 1.0); // tilt
    grassObjBuffer.blades[instanceIndex].data.w = bladeHash < 0.05 ? 0.0 : .1; // bend
    grassObjBuffer.blades[instanceIndex].data2.x = bladeHash;
    grassObjBuffer.blades[instanceIndex].data2.y = pushConstants.windStrength;
  }
}