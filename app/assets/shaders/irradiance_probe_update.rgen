#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_GOOGLE_include_directive : enable

#include "bindless.glsl"
#include "bindless_tlas.glsl"
#include "scene_ubo.glsl"

layout(set = 1, binding = 0, rgba16f) uniform writeonly image2D irradianceIm;
layout(set = 1, binding = 1, rgba16f) uniform writeonly image2D dirIm;

const float GOLDEN_RATIO = 1.6180339887;
const uint NUM_RAYS = 64;
const float PI = 3.14159265359;
const float EPSILON = 1e-6;

struct hitPayload
{
  vec3 irradiance;
  vec3 hitPos;
  float shadow;
};

layout(location = 0) rayPayloadEXT hitPayload payload;

float rand(vec2 co){
  return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

vec3 worldDirFromFibonacciIndex(uint idx)
{
  float theta = 2.0 * PI * float(idx) / GOLDEN_RATIO;
  float phi = acos(1.0 - 2.0 * (float(idx) + 0.5) / float(NUM_RAYS));

  vec3 outDir = vec3(
    cos(theta) * sin(phi),
    sin(theta) * sin(phi),
    cos(phi));

  return normalize(outDir);
}

void main()
{
  // Find which probe this invocation corresponds to
  ivec2 pixel = ivec2(gl_LaunchIDEXT.xy);
  const int probePixelSize = 8; // sqrt(256)
  const int numProbesPerPlane = 32;
  const int numPlanes = 8;

  int probeX = pixel.x / probePixelSize;
  int probeY = pixel.y / (probePixelSize * numProbesPerPlane);   // THIS IS THE HEIGHT, AKA PLANE!
  int probeZ = (pixel.y - (probeY * probePixelSize * numProbesPerPlane)) / probePixelSize;

  ivec2 pixelWithinProbe = ivec2(pixel.x - probeX * probePixelSize, pixel.y - probeY * numProbesPerPlane * probePixelSize - probeZ * probePixelSize);
  int rayIndex = pixelWithinProbe.y * probePixelSize + pixelWithinProbe.x;

  vec3 origin = vec3(float(probeX), float(probeY) * 2.0, float(probeZ));

  // Create a directional vector from the "ray index"
  vec3 worldDir = worldDirFromFibonacciIndex(rayIndex);

  // Create a random rotation
  /*float timeMod = mod(ubo.time, 2.0*acos(-1.0)); // To stop loss of precision when ubo.time gets big
  float cosT = cos(timeMod);
  float sinT = sin(timeMod);

  mat3 rotX;
  // below are columns, not rows...
  rotX[0] = vec3(1.0, 0.0, 0.0); 
  rotX[1] = vec3(0.0, cosT, sinT);
  rotX[2] = vec3(0.0, -sinT, cosT);

  worldDir = normalize(rotX * worldDir);*/

  /*vec3 jitter = vec3(
    rand(vec2(ubo.time, -ubo.time)) * 2.0 - 1.0,
    rand(vec2(ubo.time, ubo.time)) * 2.0 - 1.0,
    rand(vec2(-ubo.time, ubo.time)) * 2.0 - 1.0
  );

  worldDir += jitter;
  worldDir = normalize(worldDir);*/

  uint  rayFlags =  gl_RayFlagsOpaqueEXT; // All geometry is considered opaque
  float tMin     = 0.1;
  float tMax     = 100.0;

  payload.irradiance = vec3(0.0);

  traceRayEXT(tlas,     // acceleration structure
        rayFlags,       // rayFlags
        0xFF,           // cullMask
        0,              // sbtRecordOffset
        0,              // sbtRecordStride
        0,              // missIndex
        origin,         // ray origin
        tMin,           // ray min range
        worldDir,       // ray direction
        tMax,           // ray max range
        0);             // payload (location = 0)

  //if (length(payload.irradiance) > EPSILON) {
    imageStore(irradianceIm, pixel, vec4(payload.irradiance.rgb, 1.0));
  //}
  imageStore(dirIm, pixel, vec4(worldDir.xyz, 1.0));

}